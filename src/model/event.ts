/**
 * A22 v3.0 Event Model
 *
 * Events are the atomic ontology of A22.
 * All meaning is temporal - events happen in time.
 * Histories are append-only, time-ordered streams of events.
 */

/**
 * Core A22 Event - the fundamental unit of the system
 * Events are immutable and represent something that happened at a specific time
 */
export interface A22Event {
  /** Fully qualified event type (namespace.action, e.g., "message.received") */
  type: string;

  /** ISO 8601 UTC timestamp when the event occurred */
  time: string;

  /** Source agent ID or external system identifier */
  source: string;

  /** UUID for correlation across event chains */
  correlationId: string;

  /** Event-specific payload data */
  data: Record<string, unknown>;

  /** Optional metadata for runtime use */
  metadata?: EventMetadata;
}

/**
 * Event metadata for tracing and debugging
 */
export interface EventMetadata {
  /** Distributed trace ID */
  traceId?: string;

  /** Parent event ID for causality chains */
  parentEventId?: string;

  /** Runtime-specific metadata */
  runtime?: Record<string, unknown>;
}

/**
 * Event pattern for matching event types
 * Supports wildcards: "message.*", "user.*", etc.
 */
export interface EventPattern {
  /** Pattern string (e.g., "message.*", "conversation.reply") */
  pattern: string;

  /** Compiled matcher function (generated by runtime) */
  matches: (eventType: string) => boolean;
}

/**
 * Event history - time-ordered, append-only stream of events
 * Histories are never mutated, only grown
 */
export interface EventHistory {
  /** Pattern that defines this history */
  pattern: EventPattern;

  /** All matching events in temporal order (oldest first) */
  events: A22Event[];

  /** Index for efficient lookups */
  index: EventHistoryIndex;

  /** Creation timestamp */
  createdAt: string;

  /** Last updated timestamp */
  updatedAt: string;
}

/**
 * Index structure for efficient event queries
 */
export interface EventHistoryIndex {
  /** Events indexed by type */
  byType: Map<string, A22Event[]>;

  /** Events indexed by source */
  bySource: Map<string, A22Event[]>;

  /** Events indexed by correlation ID */
  byCorrelationId: Map<string, A22Event[]>;
}

/**
 * Event pattern matcher builder
 * Creates a pattern matcher function from a pattern string
 */
export function createEventPattern(pattern: string): EventPattern {
  // Convert wildcard pattern to regex
  const regexPattern = pattern
    .replace(/\./g, '\\.')  // Escape dots
    .replace(/\*/g, '.*');  // Convert * to regex .*

  const regex = new RegExp(`^${regexPattern}$`);

  return {
    pattern,
    matches: (eventType: string) => regex.test(eventType)
  };
}

/**
 * History window for scoping event queries
 */
export interface HistoryWindow {
  /** Maximum number of events to include */
  maxEvents?: number;

  /** Time-based window (ISO 8601 duration, e.g., "PT1H" for 1 hour) */
  timeWindow?: string;

  /** Custom filter expression */
  filter?: string;

  /** Start time boundary (ISO 8601) */
  after?: string;

  /** End time boundary (ISO 8601) */
  before?: string;
}

/**
 * Event query options for retrieving events
 */
export interface EventQuery {
  /** Event pattern to match */
  pattern: EventPattern;

  /** Optional window for scoping results */
  window?: HistoryWindow;

  /** Sort order */
  orderBy?: 'time_asc' | 'time_desc';

  /** Pagination limit */
  limit?: number;

  /** Pagination offset */
  offset?: number;
}

/**
 * Event emission specification
 * Declares what events an agent can produce
 */
export interface EventEmission {
  /** Event type pattern the agent can emit */
  eventType: string;

  /** Optional conditions for emission */
  condition?: EmissionCondition;

  /** Description of when/why this event is emitted */
  description?: string;
}

/**
 * Conditions under which an event is emitted
 */
export interface EmissionCondition {
  /** Emit when this event type is received */
  onEvent?: string;

  /** Emit when this interpretation becomes available */
  onInterpretation?: string;

  /** Emit when this condition evaluates to true */
  when?: string;
}

/**
 * Event subscription specification
 * Declares what events an agent responds to
 */
export interface EventSubscription {
  /** Event pattern to subscribe to */
  pattern: EventPattern;

  /** Subscription type */
  type: 'listens' | 'notices';

  /** Description of how the agent handles this event */
  description?: string;
}

/**
 * History access pattern specification
 * Declares what event histories an agent can view
 */
export interface HistoryAccess {
  /** Event pattern to track */
  pattern: EventPattern;

  /** Optional window for scoping history */
  window?: HistoryWindow;

  /** Description of why this history is needed */
  description?: string;
}

/**
 * Event handler function type
 */
export type EventHandler = (event: A22Event) => void | Promise<void>;

/**
 * Event subscription handle
 */
export interface EventSubscriptionHandle {
  /** Unique subscription ID */
  id: string;

  /** Pattern being subscribed to */
  pattern: EventPattern;

  /** Unsubscribe from events */
  unsubscribe(): Promise<void>;
}
